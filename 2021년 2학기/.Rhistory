knitr::opts_chunk$set(echo = TRUE)
xdata <- c(5,1,5,14,3,19,1,1,4,22)
Time <- c(94.32,15.72,62.88,125.76,5.24,31.44,1.05,1.05,2.10,10.48)
nx <- length(xdata)
Nsim <- 5000
beta <- array(0,Nsim)
lambda <- matrix(0,Nsim,nx)
alpha <- 2.5
gamma <- 0.1
delta <- 0.01
# gipps samling
set.seed(0)
for (i in 2:Nsim){
for (j in 1:nx){
lambda[i,j] <- rgamma(1, shape = xdata[j] + alpha, rate = Time[j] + beta[i-1])
}
beta[i] <- rgamma(1,shape = gamma + nx*alpha, rate = delta + sum(lambda[i,]))
}
after_lambda <- lambda[Nsim,] * Time
for (i in 1:10){
tst <- rpois(100000,after_lambda[i])
print(HDInterval::hdi(tst))
cat(xdata[i], "\n")
}
xdata <- c(5,1,5,14,3,19,1,1,4,22)
Time <- c(94.32,15.72,62.88,125.76,5.24,31.44,1.05,1.05,2.10,10.48)
nx <- length(xdata)
Nsim <- 5000
beta <- array(0,Nsim)
lambda <- matrix(0,Nsim,nx)
alpha <- 2.5
gamma <- 0.1
delta <- 0.01
# gipps samling
set.seed(0)
for (i in 2:Nsim){
for (j in 1:nx){
lambda[i,j] <- rgamma(1, shape = xdata[j] + alpha, rate = Time[j] + beta[i-1])
}
beta[i] <- rgamma(1,shape = gamma + nx*alpha, rate = delta + sum(lambda[i,]))
}
after_lambda <- lambda[Nsim,] * Time
for (i in 1:10){
tst <- rpois(100000,after_lambda[i])
print(HDInterval::hdi(tst))
cat("\n")
}
xdata <- c(5,1,5,14,3,19,1,1,4,22)
Time <- c(94.32,15.72,62.88,125.76,5.24,31.44,1.05,1.05,2.10,10.48)
nx <- length(xdata)
Nsim <- 5000
beta <- array(0,Nsim)
lambda <- matrix(0,Nsim,nx)
alpha <- 2.5
gamma <- 0.1
delta <- 0.01
# gipps samling
set.seed(0)
for (i in 2:Nsim){
for (j in 1:nx){
lambda[i,j] <- rgamma(1, shape = xdata[j] + alpha, rate = Time[j] + beta[i-1])
}
beta[i] <- rgamma(1,shape = gamma + nx*alpha, rate = delta + sum(lambda[i,]))
}
after_lambda <- lambda[Nsim,] * Time
for (i in 1:10){
tst <- rpois(100000,after_lambda[i])
print(HDInterval::hdi(tst))
cat("\n")
}
xdata <- c(5,1,5,14,3,19,1,1,4,22)
Time <- c(94.32,15.72,62.88,125.76,5.24,31.44,1.05,1.05,2.10,10.48)
nx <- length(xdata)
Nsim <- 5000
beta <- array(0,Nsim)
lambda <- matrix(0,Nsim,nx)
alpha <- 2.5
gamma <- 0.1
delta <- 0.01
# gipps samling
set.seed(1024)
for (i in 2:Nsim){
for (j in 1:nx){
lambda[i,j] <- rgamma(1, shape = xdata[j] + alpha, rate = Time[j] + beta[i-1])
}
beta[i] <- rgamma(1,shape = gamma + nx*alpha, rate = delta + sum(lambda[i,]))
}
after_lambda <- lambda[Nsim,] * Time
for (i in 1:10){
tst <- rpois(100000,after_lambda[i])
print(HDInterval::hdi(tst))
cat("\n")
}
xdata <- c(5,1,5,14,3,19,1,1,4,22)
Time <- c(94.32,15.72,62.88,125.76,5.24,31.44,1.05,1.05,2.10,10.48)
nx <- length(xdata)
Nsim <- 5000
beta <- array(0,Nsim)
lambda <- matrix(0,Nsim,nx)
alpha <- 2.5
gamma <- 0.1
delta <- 0.01
# gipps samling
set.seed(1024)
for (i in 2:Nsim){
for (j in 1:nx){
lambda[i,j] <- rgamma(1, shape = xdata[j] + alpha, rate = Time[j] + beta[i-1])
}
beta[i] <- rgamma(1,shape = gamma + nx*alpha, rate = delta + sum(lambda[i,]))
}
after_lambda <- lambda[Nsim,] * Time
for (i in 1:10){
tst <- rpois(100000,after_lambda[i])
print(HDInterval::hdi(tst))
cat("\n")
}
n_iter <- 5000
beta <- array(0,n_iter)
lambda <- matrix(0,n_iter,10)
beta[1] <- runif(1,-10,10)
lambda[1,] <- runif(10,-10,10)
# 시뮬레이션 횟수
sd <- 5
old <- runif(10,-10,10)
new <- array(0,10)
x_data <- matrix(0,n_iter,10)
for (i in 1:n_iter){
#new <- rnorm(1,init,sd) # 제안함수
for (j in 1:10){
new[j] <- rnorm(1,old[j],sd)
target <- dpois(round(new[j],0),after_lambda[j]) / dpois(round(old[j],0),after_lambda[j])
#target <- dgamma(new[j], shape = xdata[j] + alpha, rate = Time[j] + beta[i-1],log = T) - dgamma(old[j], shape = xdata[j] + alpha, rate = Time[j] + beta[i-1], log = T)
if (dpois(round(old[j],0),after_lambda[j]) == 0 || runif(1) > target){
#accept
x_data[i,j] <- old[j]
}
else{
#reject
x_data[i,j] <- new[j]
old[j] <- new[j]
}
}
}
x_data
for (i in 1:10){
tst <- x_data[,i]
print(i)
print(HDInterval::hdi(tst))
cat("\n")
}
n_iter <- 5000
beta <- array(0,n_iter)
lambda <- matrix(0,n_iter,10)
beta[1] <- runif(1,-10,10)
lambda[1,] <- runif(10,-10,10)
# 시뮬레이션 횟수
sd <- 5
old <- runif(10,-10,10)
new <- array(0,10)
x_data <- matrix(0,n_iter,10)
set.seed(100)
for (i in 1:n_iter){
#new <- rnorm(1,init,sd) # 제안함수
for (j in 1:10){
new[j] <- rnorm(1,old[j],sd)
target <- dpois(round(new[j],0),after_lambda[j]) / dpois(round(old[j],0),after_lambda[j])
if (dpois(round(old[j],0),after_lambda[j]) == 0 || runif(1) > target){
#accept
x_data[i,j] <- old[j]
}
else{
#reject
x_data[i,j] <- new[j]
old[j] <- new[j]
}
}
}
for (i in 1:10){
tst <- x_data[,i]
print(i)
print(HDInterval::hdi(tst))
cat("\n")
}
n_iter <- 5000
beta <- array(0,n_iter)
lambda <- matrix(0,n_iter,10)
beta[1] <- runif(1,-10,10)
lambda[1,] <- runif(10,-10,10)
# 시뮬레이션 횟수
sd <- 5
old <- runif(10,-10,10)
new <- array(0,10)
x_data <- matrix(0,n_iter,10)
set.seed(1000)
for (i in 1:n_iter){
#new <- rnorm(1,init,sd) # 제안함수
for (j in 1:10){
new[j] <- rnorm(1,old[j],sd)
target <- dpois(round(new[j],0),after_lambda[j]) / dpois(round(old[j],0),after_lambda[j])
if (dpois(round(old[j],0),after_lambda[j]) == 0 || runif(1) > target){
#accept
x_data[i,j] <- old[j]
}
else{
#reject
x_data[i,j] <- new[j]
old[j] <- new[j]
}
}
}
for (i in 1:10){
tst <- x_data[,i]
print(i)
print(HDInterval::hdi(tst))
cat("\n")
}
n_iter <- 5000
beta <- array(0,n_iter)
lambda <- matrix(0,n_iter,10)
beta[1] <- runif(1,-10,10)
lambda[1,] <- runif(10,-10,10)
# 시뮬레이션 횟수
sd <- 5
old <- runif(10,-10,10)
new <- array(0,10)
x_data <- matrix(0,n_iter,10)
set.seed(1000)
for (i in 1:n_iter){
#new <- rnorm(1,init,sd) # 제안함수
for (j in 1:10){
new[j] <- rnorm(1,old[j],sd)
target <- dpois(round(new[j],0),after_lambda[j]) / dpois(round(old[j],0),after_lambda[j])
if (dpois(round(old[j],0),after_lambda[j]) == 0 || runif(1) > target){
#accept
x_data[i,j] <- old[j]
}
else{
#reject
x_data[i,j] <- new[j]
old[j] <- new[j]
}
}
}
for (i in 1:10){
tst <- x_data[,i]
print(i)
print(HDInterval::hdi(tst))
cat("\n")
}
n_iter <- 5000
beta <- array(0,n_iter)
lambda <- matrix(0,n_iter,10)
beta[1] <- runif(1,-10,10)
lambda[1,] <- runif(10,-10,10)
# 시뮬레이션 횟수
sd <- 5
old <- runif(10,-10,10)
new <- array(0,10)
x_data <- matrix(0,n_iter,10)
for (i in 1:n_iter){
#new <- rnorm(1,init,sd) # 제안함수
for (j in 1:10){
new[j] <- rnorm(1,old[j],sd)
target <- dpois(round(new[j],0),after_lambda[j]) / dpois(round(old[j],0),after_lambda[j])
if (dpois(round(old[j],0),after_lambda[j]) == 0 || runif(1) > target){
#accept
x_data[i,j] <- old[j]
}
else{
#reject
x_data[i,j] <- new[j]
old[j] <- new[j]
}
}
}
for (i in 1:10){
tst <- x_data[,i]
print(i)
print(HDInterval::hdi(tst))
cat("\n")
}
n_iter <- 5000
beta <- array(0,n_iter)
lambda <- matrix(0,n_iter,10)
beta[1] <- runif(1,-10,10)
lambda[1,] <- runif(10,-10,10)
# 시뮬레이션 횟수
sd <- 5
old <- runif(10,-10,10)
new <- array(0,10)
x_data <- matrix(0,n_iter,10)
for (i in 1:n_iter){
#new <- rnorm(1,init,sd) # 제안함수
for (j in 1:10){
new[j] <- rnorm(1,old[j],sd)
target <- dpois(round(new[j],0),after_lambda[j]) / dpois(round(old[j],0),after_lambda[j])
if (dpois(round(old[j],0),after_lambda[j]) == 0 || runif(1) > target){
#accept
x_data[i,j] <- old[j]
}
else{
#reject
x_data[i,j] <- new[j]
old[j] <- new[j]
}
}
}
for (i in 1:10){
tst <- x_data[,i]
print(i)
print(HDInterval::hdi(tst))
cat("\n")
}
x_data
n_iter <- 5000
beta <- array(0,n_iter)
lambda <- matrix(0,n_iter,10)
beta[1] <- runif(1,-10,10)
lambda[1,] <- runif(10,-10,10)
# 시뮬레이션 횟수
sd <- 5
old <- runif(10,-10,10)
new <- array(0,10)
x_data <- matrix(0,n_iter,10)
for (i in 1:n_iter){
#new <- rnorm(1,init,sd) # 제안함수
for (j in 1:10){
new[j] <- rnorm(1,old[j],sd)
target <- dpois(round(new[j],0),after_lambda[j]) / dpois(round(old[j],0),after_lambda[j])
if (dpois(round(old[j],0),after_lambda[j]) == 0 || runif(1) > target){
#accept
x_data[i,j] <- old[j]
}
else{
#reject
x_data[i,j] <- new[j]
old[j] <- new[j]
}
}
}
for (i in 1:10){
tst <- x_data[,i]
print(i)
print(HDInterval::hdi(tst))
cat("\n")
}
# 1) Determine the distributon
# 평균과 표준편차는 다음과 같다.
mean(times)
# 1) Determine the distributon
# 히스토그램을 그렸고 오른쪽으로 기울어진 형태의 분포를 확인할 수 있다.
times <- c(12,11,6,2,19,
5,34,4,1,4,
8,7,1,3,5,
21,6,11,8,2,
8,6,4,5,1,
18,9,5,1,9,
21,1,1,5,3,
14,5,3,4,5,1
)
# 평균과 표준편차는 다음과 같다.
mean(times)
sd(times)
h <- hist(times, plot = F)
plot(h)
sample_mean <- function(data,i){
media <- mean(data[i])
n <- length(i)
v <- (n-1) * var(data[i]) / n^2
c(media,v)
}
library(boot)
B <- 200
bootstrap_mean <- boot(times, sample_mean, R = B)
boot.ci(bootstrap_mean)
data <- iris
data
data.columns()
data[:]
type(data)
data.astype
data
data <- data.frame(iris)
data
class(data)
# columns
names(data)
# columns
names(data)[1]
names(data)[-1]
names(data[2:4])
# columns
columns <- names(data)
columns[1]
columns[2:4]
# columns
columns <- names(data)
target <- columns[1]
feature <- columns[2:4]
# 다중회귀분석
lm(target ~ feature)
# 다중회귀분석
lm(target ~ feature, data = data)
feature
feature[0]
feature
feature[1]
feature[1] + feature[2]
paste(feature,sep = "+")
# 다중회귀분석
lm(target ~ "Sepal.Width"+"Petal.Length"+"Petal.Width", data = data)
target
data
# 다중회귀분석
lm(target ~ Sepal.Width+Petal.Length+Petal.Width, data = data)
target
# 다중회귀분석
lm(Sepal.Length ~ Sepal.Width+Petal.Length+Petal.Width, data = data)
# 다중회귀분석
model <- lm(Sepal.Length ~ Sepal.Width+Petal.Length+Petal.Width, data = data)
summary(model)
length(data)
data
# 크기 확인
dim(data)
nrow(data)
ncol(data)
summary(model)
model.weights()
model.weights(1)
model.weights(data[0])
data[1]
data[1,:]
data[1,]
model.predict([3.5,1.4,0.2 ])
predict(model, newdata = [3.5,1.4,0.2])
newdata <- data.frame([3.5,1.4,0.2])
newdata <- data.frame(3.5,1.4,0.2)
newdata
predict(model, newdata = newdata)
colnames(newdata) <-
columns
colnames(newdata) <-
columns
columns
columns[2:4]
colnames(newdata) <- columns[2:4]
newdata
predict(model, newdata = newdata)
data[0]
data[1]
data[1,]
# 모형진단
par(mfrow = c(2,2))
plot(model)
# 등분산성
library(car)
residuals(model)
durbinWatsonTest(residuals(model))
durbinWatsonTest(model)
# 정규성
shapiro.test(model)
# 정규성
shapiro.test(residuals(model))
# 평균 0
mean(residuals(model))
# 5)
std(residuals(model))
# 5)
var(residuals(model))
# 5)
sqrt(var(residuals(model)))
fitted(model[1:5,])
fitted(model[1:5])
fitted(model)
fitted(model) -
data[,1]
fitted(model) -
iris[,1]
fitted(model) -
iris[,1]
# 예측해보기
newdata <- data.frame(3.5,1.4,0.2)
fitted(model) -
iris[,1]
mean((fitted(model) - iris[,1])**2)
mse <- mean((fitted(model) - iris[,1])**2)
mse
# confint
confint(model)
#
fitted(model)
#
fitted(model)[:5]
#
fitted(model)[1:5]
# 모델분석
summary(model)
anova(model)
pnorm(99)
pnorm(1)
pnorm(0)
qnorm(1.96)
qnorm(1)
qnorm(0)
pnorm(1.645)
#
qnorm(0.95)
# boxplot
boxplot(mtcars$mpg)
install.packages("caret")
setwd("~/Documents/깃허브/Career/2021년 2학기")
